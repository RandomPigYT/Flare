#include <clang/AST/AST.h>
#include <clang/AST/ASTConsumer.h>
#include <clang/AST/RecursiveASTVisitor.h>
#include <clang/Basic/IdentifierTable.h>
#include <clang/Basic/LangOptions.h>
#include <clang/Frontend/CompilerInstance.h>
#include <clang/Frontend/FrontendAction.h>
#include <clang/Frontend/FrontendActions.h>
#include <clang/Frontend/FrontendPluginRegistry.h>
#include <clang/Tooling/CommonOptionsParser.h>
#include <clang/Tooling/Tooling.h>
#include <llvm/ADT/StringRef.h>
#include <llvm/IR/Value.h>
#include <llvm/Support/CommandLine.h>
#include <llvm/Support/raw_ostream.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <iostream>
#include <string>

#include "typeinfo.hpp"
#include "handleDecl.hpp"

// Define a visitor for traversing the AST
class ASTDeclVisitor : public clang::RecursiveASTVisitor<ASTDeclVisitor> {
  char *filename;

 public:
  ASTDeclVisitor(char *file) {
    filename = file;
    strcpy(filename, file);
  }

  ~ASTDeclVisitor() { free(filename); }

  // Override method for visiting all AST nodes
  bool TraverseDecl(clang::Decl *D) {
    if (clang::TranslationUnitDecl *tr =
            clang::dyn_cast<clang::TranslationUnitDecl>(D)) {
      printf("file: %s\n\nTranslation ID: %ld\n", filename, tr->getID());
    }

    // D->dump(llvm::outs());
    clang::RecordDecl *rd = clang::dyn_cast<clang::RecordDecl>(D);

    if (rd) {
      printf("%s\t%ld\n", rd->getNameAsString().c_str(), rd->getID());
			
			Reflection::handleRecordDecl()
    }

    if (clang::TypedefDecl *TD = clang::dyn_cast<clang::TypedefDecl>(D)) {
      clang::QualType q = TD->getUnderlyingType();
      rd = q->getAsRecordDecl();

      if (rd) printf("typedef: %s\t", TD->getNameAsString().c_str());
      if (rd) printf("%ld\n", rd->getID());
    }
    return RecursiveASTVisitor::TraverseDecl(D);
  }
};

// Define an ASTConsumer for processing the AST
class MyASTConsumer : public clang::ASTConsumer {
  char *filename;
  ASTDeclVisitor Visitor;

 public:
  MyASTConsumer(char *file) : filename(file), Visitor(filename) {}

  // Override method for setting up the AST visitor
  void HandleTranslationUnit(clang::ASTContext &Context) override {
    if (Visitor.TraverseDecl(Context.getTranslationUnitDecl())) {
      printf("Done!\n");
    }
  }
};

// Define a FrontendAction for the plugin
class ReflectionASTAction : public clang::ASTFrontendAction {
  std::vector<std::string> args;

 protected:
  // Override method for creating the AST consumer
  std::unique_ptr<clang::ASTConsumer> CreateASTConsumer(
      clang::CompilerInstance &, clang::StringRef file) override {
    return std::make_unique<MyASTConsumer>(strdup((char *)file.str().c_str()));
  }
};

llvm::cl::OptionCategory catagory("Reflection");

int main(int argc, char **argv) {
  if (argc <= 1) {
    fprintf(stderr, "Bad usage\n");
    return EXIT_FAILURE;
  }

  std::vector<Reflection::typeInfo_t> typeinfo;

  llvm::Expected<clang::tooling::CommonOptionsParser> optionsParser =
      clang::tooling::CommonOptionsParser::create(argc, (const char **)argv,
                                                  catagory);

  clang::tooling::ClangTool tool(optionsParser->getCompilations(),
                                 optionsParser->getSourcePathList());

  tool.run(
      clang::tooling::newFrontendActionFactory<ReflectionASTAction>().get());

  return 0;
}
